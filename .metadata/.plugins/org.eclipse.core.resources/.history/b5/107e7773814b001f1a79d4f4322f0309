package com.lucas.controllers;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.lucas.Infra.Security.SecurityConfigurations;
import com.lucas.Infra.Security.TokenServico;
import com.lucas.models.AdminUserDetails;
import com.lucas.models.Adminstrador;
import com.lucas.models.Barbearia;
import com.lucas.models.Barbeiro;
import com.lucas.models.CustomUserDetails;
import com.lucas.models.EnumRoles;
import com.lucas.models.dtos.AutenticacaoDTO;
import com.lucas.models.dtos.LoginResponseDTO;
import com.lucas.models.dtos.RegistrarDTO;
import com.lucas.repositories.AdministradorRepositorio;
import com.lucas.repositories.BarbeiroRepositorio;


@RestController
@RequestMapping("auth")
public class AutenticacaoControler {
	
	@Autowired
	private AuthenticationManager authenticationManager;
	
	@Autowired
	private BarbeiroRepositorio repositorio;
	
	@Autowired
	private AdministradorRepositorio adminRepositorio;
	
	@Autowired
	private TokenServico tokenServico;
	
	
	/*@PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody @Validated AutenticacaoDTO data) {
        try {
            var usernamePassword = new UsernamePasswordAuthenticationToken(data.email(), data.senha());
            var auth = this.authenticationManager.authenticate(usernamePassword);
            //System.out.println("Tentativa de login com email: " + data.email() + " e senha: " + data.senha());

            
            var token = tokenServico.gerarToken((Barbeiro)auth.getPrincipal());
            
            return ResponseEntity.ok(new LoginResponseDTO(token));
            
        } catch (AuthenticationException e) {
            System.out.println("Erro de autenticação: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Credenciais inválidas");
        }
    }*/
	
	
	/*@PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody AutenticacaoDTO data) {
        try {
            Authentication auth = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                		data.email(), data.senha()));

            //var userDetails = (Barbeiro) auth.getPrincipal();
            //var token = tokenServico.gerarToken(userDetails);

            /*CustomUserDetails userDetails = (CustomUserDetails) auth.getPrincipal();
            Barbeiro barbeiro = userDetails.getBarbeiro();
            
            String token = tokenServico.gerarToken(barbeiro);
            //
            AdminUserDetails userDetails = (AdminUserDetails) auth.getPrincipal();
            Adminstrador admin = userDetails.getAdmin();
            
            String token = tokenServico.AdminGerarToken(admin);
            
            SecurityContextHolder.getContext().setAuthentication(auth);
            
            return ResponseEntity.ok(new LoginResponseDTO(token));
        } catch (BadCredentialsException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Usuário inexistente ou senha inválida");
        }
    }*/ //esse tava funfando
	
	/*@PostMapping("/login")
	public ResponseEntity<?> login(@RequestBody AutenticacaoDTO data) {
	    try {
	        //Authentication auth = authenticationManager.authenticate(
	            //new UsernamePasswordAuthenticationToken(data.email(), data.senha()));
	        var usernamePassword = new UsernamePasswordAuthenticationToken(data.email(), data.senha());
            var auth = this.authenticationManager.authenticate(usernamePassword);
	       
            AdminUserDetails userDetails = (AdminUserDetails) auth.getPrincipal();
	        String token;
	        
	        //AdminUserDetails userDetails = (AdminUserDetails) principal;
            Adminstrador admin = userDetails.getAdmin();
            System.out.println("Adminstrador autenticado: " + admin.getEmail());
            token = tokenServico.AdminGerarToken(admin);
            
	        /*if (principal instanceof AdminUserDetails) {
	            AdminUserDetails userDetails = (AdminUserDetails) principal;
	            Adminstrador admin = userDetails.getAdmin();
	            System.out.println("Adminstrador autenticado: " + admin.getEmail());
	            token = tokenServico.AdminGerarToken(admin);
	            
	        }else if (principal instanceof CustomUserDetails) {
	            CustomUserDetails userDetails = (CustomUserDetails) principal;
	            Barbeiro barbeiro = userDetails.getBarbeiro();
	            System.out.println("Barbeiro autenticado: " + barbeiro.getEmail());
	            token = tokenServico.gerarToken(barbeiro);
	        } else {
	            throw new RuntimeException("Unknown principal type");
	        }//////
	        SecurityContextHolder.getContext().setAuthentication(auth);
	        
	        return ResponseEntity.ok(new LoginResponseDTO(token));
	    } catch (BadCredentialsException e) {
	        System.out.println("Autenticação falhou para o email: " + data.email() + "senha: " + data.senha());
	        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Usuário inexistente ou senha inválida" + e.getMessage());
	    }
	}*/
	
	@PostMapping("/login")
	public ResponseEntity<?> login(@RequestBody AutenticacaoDTO data) {
	    try {
	        var usernamePassword = new UsernamePasswordAuthenticationToken(data.email(), data.senha());
	        var auth = this.authenticationManager.authenticate(usernamePassword);
	       
	        System.out.println("Senha recebida para autenticação: " + data.senha());
	        var encodedPassword = SecurityConfigurations.passwordEncoder.encode(data.senha());
	        System.out.println("Senha codificada: " + encodedPassword);
	        
	        AdminUserDetails userDetails = (AdminUserDetails) auth.getPrincipal();
	        String token;
	       
	        Adminstrador admin = userDetails.getAdmin();
	        System.out.println("Adminstrador autenticado: " + admin.getEmail());
	        token = tokenServico.AdminGerarToken(admin);

	        SecurityContextHolder.getContext().setAuthentication(auth);
	        
	        return ResponseEntity.ok(new LoginResponseDTO(token));
	    } catch (BadCredentialsException e) {
	        System.out.println("Autenticação falhou para o email: " + data.email() + " senha: " + data.senha());
	        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Usuário inexistente ou senha inválida: " + e.getMessage());
	    }
	}
	
	@PostMapping("/registrar")
	public ResponseEntity<?> registrar(@RequestBody @Validated RegistrarDTO data) {
	    try {
	        String senhaEncriptada = new BCryptPasswordEncoder().encode(data.senha());
	        Barbearia barbearia = null; // Defina isso conforme necessário
	        
            
            Adminstrador admin = new Adminstrador(data.nome(), data.email(), data.telefone(), senhaEncriptada, data.role(), barbearia);
	        //Barbeiro novoBarbeiro = new Barbeiro(data.nome(), data.email(), data.telefone(), senhaEncriptada, data.role(), null, barbearia);
	        //this.repositorio.save(novoBarbeiro);
            this.adminRepositorio.save(admin);

	        return ResponseEntity.ok().build();
	    } catch (Exception e) {
	        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Erro ao registrar novo barbeiro");
	    }
	}
	
	 /*@PostMapping("/registrar")
	public ResponseEntity<?>registrar(@RequestBody @Validated RegistrarDTO data) {
		
		try {
            Authentication auth = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                		data.email(), data.senha()));


            AdminUserDetails userDetails = (AdminUserDetails) auth.getPrincipal();
            
            Adminstrador admin = userDetails.getAdmin();
            Barbearia barbearia = admin.getBarbearia(); 
            *//*
            SecurityContextHolder.getContext().setAuthentication(auth);
            
            //String senhaEncriptada = new BCryptPasswordEncoder().encode(data.senha());
    		//Barbeiro novoBarbeiro = new Barbeiro(data.nome(), data.email(), data.telefone(), senhaEncriptada, data.role(),admin ,barbearia);
    		
    		System.out.println("nome do barbeiro eh: " + data.nome());
    		this.repositorio.save(novoBarbeiro);
            
    		//return ResponseEntity.ok(new LoginResponseDTO(token));
    		return ResponseEntity.ok().build();
       
		} catch (BadCredentialsException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Administrador inexistente ou senha inválida");
        }*/
	
	// }esse foi o ultimo
	
	
	/*@PostMapping("/registrar")
	public ResponseEntity<?>registrar(@RequestHeader("Authorization") String token, @RequestBody @Validated RegistrarDTO data) {
		
		//String tokenWithoutBearer = token.substring(7); // Remove "Bearer " prefix
		//String email = tokenServico.validarToken(tokenWithoutBearer);
		
		//String email = tokenServico.validarToken(token);
		String email = token;
		
	    if (email == null) {
	        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Invalid token");
	    }

	    Adminstrador adminstrador = adminRepositorio.findByEmail(email);
	    
	    if (adminstrador == null || !adminstrador.getRole().equals(EnumRoles.ADMIN)) {
	        return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Access denied");
	    }
		if (this.repositorio.findByEmail(data.email()) != null) return ResponseEntity.badRequest().build();
		
		try {
            Authentication auth = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                		data.email(), data.senha()));


            AdminUserDetails userDetails = (AdminUserDetails) auth.getPrincipal();
            
            Adminstrador admin = userDetails.getAdmin();
            Barbearia barbearia = admin.getBarbearia(); 
            
            SecurityContextHolder.getContext().setAuthentication(auth);
            
            String senhaEncriptada = new BCryptPasswordEncoder().encode(data.senha());
    		Barbeiro novoBarbeiro = new Barbeiro(data.nome(), data.email(), data.telefone(), senhaEncriptada, data.role(),admin ,barbearia);
    		
    		System.out.println("nome do barbeiro eh: " + data.nome());
    		this.repositorio.save(novoBarbeiro);
            
    		//return ResponseEntity.ok(new LoginResponseDTO(token));
    		return ResponseEntity.ok().build();
       
		} catch (BadCredentialsException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Administrador inexistente ou senha inválida");
        }
	}*/
}
